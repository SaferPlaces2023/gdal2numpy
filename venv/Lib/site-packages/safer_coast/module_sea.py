# -------------------------------------------------------------------------------
# Licence:
# Copyright (c) 2019-2021
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
# OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.
#
#
# Name:        module_sea.py
# Purpose:
#
# Author:      Luzzi Valerio
#
# Created:     12/03/2019
# -------------------------------------------------------------------------------
import datetime
import os.path

import numpy as np
from numba import njit
from gdal2numpy import GDAL2Numpy, Numpy2GTiff, RasterizeLike
from gdal2numpy import SetTags, israster, isfile, iss3, tempname4S3
from .filesystem import juststem, justpath, justfname, forceext, justext, md5text
from .module_utils import *
from .module_shoreline import barrier_dilatation, shoreline_from_sea_mask
from .module_gdal import feature_selection
from .gdalwarp import SetGDALEnviron
from .module_log import Logger, set_level


@njit
def LabelingSea(dem, mask):
    """
    LabelingSea - Detect the blob with dem <= 0 with the max area
    """
    m, n = dem.shape
    labels = np.zeros_like(dem, dtype=np.uint32)
    object_id = 0
    area = {0: 0}  # object_id:area
    minx = {0: 0}  # object_id:minx
    miny = {0: 0}  #
    maxx = {0: 0}  #
    maxy = {0: 0}  #
    # precision = {0: 0}  # object_id:pixels water validated
    for ii in range(m):
        for jj in range(n):
            c = ii, jj
            if (dem[c] <= 0 or np.isnan(dem[c])) and labels[c] == 0:

                object_id += 1
                labels[c] = object_id  # 1 ,2, 3,
                area[object_id] = 0
                # precision[object_id] = 0

                L = [c]
                while len(L):
                    i, j = L.pop()
                    area[object_id] += 1
                    # w = 1 if water[i, j] == 1 else 0
                    # precision[object_id] += w
                    if object_id not in minx:
                        minx[object_id] = j
                        miny[object_id] = i
                        maxx[object_id] = j
                        maxy[object_id] = i
                    else:
                        minx[object_id] = min(j, minx[object_id])
                        miny[object_id] = min(i, miny[object_id])
                        maxx[object_id] = max(j, maxx[object_id])
                        maxy[object_id] = max(i, maxy[object_id])

                    for ne in ((i - 1, j - 1), (i - 1, j), (i - 1, j + 1),
                               (i, j - 1), (i, j + 1),
                               (i + 1, j - 1), (i + 1, j), (i + 1, j + 1)):
                        if 0 <= ne[0] < m and 0 <= ne[1] < n:
                            if labels[ne] == 0 and (dem[ne] <= 0 or np.isnan(dem[ne])):
                                L.append(ne)
                                labels[ne] = object_id
                L = None

    # finale pass to delete blobs with area<10% of the file
    # If no blob is found, the threshold is lowered by 1%
    threshold = 0.10

    while np.sum(mask) == 0 and threshold > 0:
        for ii in range(m):
            for jj in range(n):
                object_id = labels[ii, jj]

                if object_id > 0:

                    # keep only the blob that touch borders
                    if minx[object_id] == 0 or maxx[object_id] == n - 1 or \
                            miny[object_id] == 0 or maxy[object_id] == m - 1:
                        # the blob touch the border
                        if area[object_id] / (m * n) >= threshold:
                            mask[ii, jj] = 1

        threshold -= 0.01

    labels = None
    # --- the end ---


@njit
def SeaGrowing(src, dem, water):
    """
    Function to calcolate the flood water
    From each src-point we grow of 1 pixel
    propagating the src elevation
    """
    level = 0
    m, n = dem.shape
    steps = np.zeros((m, n), dtype=np.uint32)  # temporary

    # init steps
    for i in range(m):
        for j in range(n):
            if src[i, j] > 0:
                steps[i, j] = 1

    pixels_to_flood, level = 1, 0
    while pixels_to_flood:
        pixels_to_flood = 0
        level += 1
        for i in range(1, m - 1):
            for j in range(1, n - 1):
                if steps[i, j] == level:

                    z0 = src[i, j] if level == 1 else water[i, j]
                    # accrescimento di un pixel in tutte le direzioni tranne per
                    #  - i punti con elevazione superiore
                    #  - collisioni con altri accrescimenti
                    for ne in ((i - 1, j - 1), (i - 1, j), (i - 1, j + 1),
                               (i, j - 1), (i, j + 1),
                               (i + 1, j - 1), (i + 1, j), (i + 1, j + 1)):
                        if 0 <= ne[0] < m and 0 <= ne[1] < n:
                            if np.isnan(water[ne]) and dem[ne] <= z0:
                                water[ne] = z0
                                steps[ne] = level + 1
                                pixels_to_flood += 1

    steps = None


@njit
def SeaGrowingMemOptimized(src, dem):
    """
    Function to calcolate the flood water
    From each src-point we grow of 1 pixel
    propagating the src elevation

    Warning - In this verion result will be saved over src
    """
    level = 0
    m, n = dem.shape
    steps = np.zeros((m, n), dtype=np.uint32)

    # init steps
    for i in range(m):
        for j in range(n):
            if not np.isnan(src[i, j]):
                steps[i, j] = 1

    pixels_to_flood, level = 1, 0
    while pixels_to_flood:
        pixels_to_flood = 0
        level += 1
        for i in range(1, m - 1):
            for j in range(1, n - 1):
                if steps[i, j] == level:

                    z0 = src[i, j]
                    # accrescimento di un pixel in tutte le direzioni tranne per
                    #  - i punti con elevazione superiore
                    #  - collisioni con altri accrescimenti
                    for ne in ((i - 1, j - 1), (i - 1, j), (i - 1, j + 1),
                               (i, j - 1), (i, j + 1),
                               (i + 1, j - 1), (i + 1, j), (i + 1, j + 1)):
                        if 0 <= ne[0] < m and 0 <= ne[1] < n:
                            if np.isnan(src[ne]) and dem[ne] <= z0:
                                src[ne] = z0
                                steps[ne] = level + 1
                                pixels_to_flood += 1
    steps = None


@njit
def SeaGrowingFIFO(src, dem):
    """
    SeaGrowingFIFO
    """
    m, n = src.shape

    Sources = []  # a List of FIFO queues. One queue for each source
    Elevations = []  # The z for each source
    jstart = []  # an offset index for each queue. (workaroud)
    # init steps

    # Find sources indexes i,j
    for i in range(m):
        for j in range(n):
            if not np.isnan(src[i, j]):
                Sources.append([(i, j)])
                Elevations.append(src[i, j])
                jstart.append(np.int32(0))

    pixels_to_flood = True
    while pixels_to_flood:
        for k in range(len(Sources)):
            if len(Sources[k]) - jstart[k]:
                # pop(0) is 100 times slower than pop() function.
                # maybe this can be due to array re-organization each time you pop(0)
                # This is a workaround to simulate a pop(0) without re-organizing the array each time.

                # i,j = Sources[k].pop(0)
                i, j = Sources[k][jstart[k]]
                jstart[k] += 1

                # re-organize the array when unused cells become important ---------------------------------------------
                L = len(Sources[k])
                if jstart[k] > 100000 and jstart[k] > 3 * (L - jstart[k]):
                    # print("Memory re-organize...")
                    Sources[k] = [Sources[k][jj]
                                  for jj in range(jstart[k], len(Sources[k]))]
                    jstart[k] = 0
                # ---- end trick ---------------------------------------------------------------------------------------

                z0 = Elevations[k]
                src[i, j] = z0

                """
                for n in [(i - 1, j - 1), (i - 1, j), (i - 1, j + 1), (i, j - 1), (i, j + 1), (i + 1, j - 1), (i + 1, j),
                          (i + 1, j + 1)]:
                    if i > 0 and i < M - 1 and j > 0 and j < N - 1:
                        if np.isnan(src[n]) and dem[n]<=z0:
                            Sources[k].append(n)
                            src[n] =0   # it's super important for the sake of the performance to make a temporary mark
                                        # (any value is good) to avoid the neighbor n is double appended to Sources[k]
                """

                if i > 0 and j > 0 and np.isnan(src[i - 1, j - 1]) and dem[
                        i - 1, j - 1] <= z0:  # and ~np.isnan(dem[i-1,j-1]): redundant
                    Sources[k].append((i - 1, j - 1))
                    src[
                        i - 1, j - 1] = 0  # it's super important for the sake of the performance to make a temporary mark
                    # (any value is good) to avoid the neighbor ne is double appended to Sources[k]
                if i > 0 and np.isnan(src[i - 1, j]) and dem[i - 1, j] <= z0:
                    Sources[k].append((i - 1, j))
                    src[i - 1, j] = 0
                if i > 0 and j < n - 1 and np.isnan(src[i - 1, j + 1]) and dem[i - 1, j + 1] <= z0:
                    Sources[k].append((i - 1, j + 1))
                    src[i - 1, j + 1] = 0

                if j > 0 and np.isnan(src[i, j - 1]) and dem[i, j - 1] <= z0:
                    Sources[k].append((i, j - 1))
                    src[i, j - 1] = 0
                if j < n - 1 and np.isnan(src[i, j + 1]) and dem[i, j + 1] <= z0:
                    Sources[k].append((i, j + 1))
                    src[i, j + 1] = 0

                if i < m - 1 and j > 0 and np.isnan(src[i + 1, j - 1]) and dem[i + 1, j - 1] <= z0:
                    Sources[k].append((i + 1, j - 1))
                    src[i + 1, j - 1] = 0
                if i < m - 1 and np.isnan(src[i + 1, j]) and dem[i + 1, j] <= z0:
                    Sources[k].append((i + 1, j))
                    src[i + 1, j] = 0
                if i < m - 1 and j < n - 1 and np.isnan(src[i + 1, j + 1]) and dem[i + 1, j + 1] <= z0:
                    Sources[k].append((i + 1, j + 1))
                    src[i + 1, j + 1] = 0
                # -------------------------------------------------------------------------------------------------------
        # if just a queue is not empty don't stop iterate...
        Ns = len(Sources)
        # 14/04/2021 - Reduce the number of sources if relative propagation queue is empty
        Elevations = [Elevations[k]
                      for k in range(Ns) if len(Sources[k]) - jstart[k] > 0]
        Sources = [Sources[k]
                   for k in range(Ns) if len(Sources[k]) - jstart[k] > 0]

        # When no source has a queue it's time to end.
        pixels_to_flood = len(Sources)


@njit
def SeaGrowingFast(src, dem, water):
    """
    Warning !! questo metodo funziona bene con solo livello di mare

    Il motivo per cui siamo piu' lenti con SeaGrowingFIFO è dovuto al fatto che abbiamo piu'
    livelli di mare da propagare equamente.

    Function to calcolate the flood water
    From each src-point we grow as much as possible in all directions
    propagating the src elevation
    After for completeness we repeat for all src pixels
    """
    m, n = dem.shape
    water[:] = src[:]

    for ii in range(m):
        for jj in range(n):
            if ~np.isnan(src[ii, jj]):
                L = [(ii, jj)]
                while len(L):
                    i, j = L.pop()
                    z0 = water[i, j]
                    # accrescimento di un pixel in tutte le direzioni tranne per
                    #  - i punti con elevazione superiore
                    #  - collisioni con altri accrescimenti
                    for ne in ((i - 1, j - 1), (i - 1, j), (i - 1, j + 1),
                               (i, j - 1), (i, j + 1),
                               (i + 1, j - 1), (i + 1, j), (i + 1, j + 1)):
                        if 0 <= ne[0] < m and 0 <= ne[1] < n:
                            if np.isnan(water[ne]) and dem[ne] <= z0:
                                water[ne] = z0
                                L.append(ne)


def safer_coast_python(filedem, filesrc="", file_seamask="", filebarrier="", barrier_selection=None, filesea="",
                       filewd="",
                       z_fieldname="", z_value=None, resistance=-1, friction=False, file_shoreline="", of="GTiff",
                       debug=False):
    """
    safer_coast_python
    """
    t0 = datetime.datetime.now()
    
    set_level(verbose=False, debug=debug)
    
    SetGDALEnviron()

    workdir = justpath(tempname4S3(filedem)) if iss3(filedem) else justpath(filedem)
    
    filewd = filewd if filewd else f"{workdir}/{juststem(filedem)}.wd.tif"
    file_seamask = file_seamask if file_seamask else f"{workdir}/{juststem(filedem)}.sea_mask.tif"

    Logger.info(f"Loading dem...:<{filedem}>")
    dem, gt, prj = GDAL2Numpy(filedem, load_nodata_as=np.nan)

    # -------------------------------------------------------------------------
    # Barrier
    # -------------------------------------------------------------------------
    # 28/01/2022 patch to select some barrier from file barrier
    if barrier_selection and filebarrier and os.path.isfile(filebarrier):
        # file_selection = tempfilename(prefix="barrier_", suffix=".shp")
        file_selection = forceext(
            filebarrier, md5text(barrier_selection) + ".shp")
        # barrier_selection is an array/string of fids
        feature_selection(filebarrier, file_selection, barrier_selection)
        filebarrier = file_selection
    # end patch

    if filebarrier and isfile(filebarrier):
        print(f"Loading barrier...:<{filebarrier}>")
        barrier, gt, prj = RasterizeLike(
            filebarrier, filedem, burn_fieldname="height")
        barrier_enforced = np.zeros_like(barrier)
        barrier_dilatation(barrier, barrier_enforced)
        barrier = None
        # dem += barrier
        # 15/11/2020
        dem[barrier_enforced > 0] = barrier_enforced[barrier_enforced > 0]

        if debug:
            file_demplus = f"{workdir}/{juststem(filedem)}.plus.tif"
            Numpy2GTiff(dem, gt, prj, file_demplus, save_nodata_as=0)

    # ------------------------------------------------------------------------------------------------------------------
    # Sea mask
    # ------------------------------------------------------------------------------------------------------------------
    # 2020-11-05 - Trying to better detect the sea
    if isfile(file_seamask):
        Logger.info(f"Loading sea_mask from file:<{file_seamask}>")
        mask, gt, prj = GDAL2Numpy(
            file_seamask, dtype=np.uint8, load_nodata_as=0)
    else:
        Logger.info(f"Creating sea_mask based on modified dem...")
        t0 = datetime.datetime.now()
        mask = np.zeros_like(dem, dtype=np.uint8)
        LabelingSea(dem, mask)
        if debug:
            Numpy2GTiff(mask, gt, prj, file_seamask, save_nodata_as=255)
        t1 = datetime.datetime.now()
        Logger.info(f"Sea mask created in {(t1 - t0).total_seconds()}")

    # ------------------------------------------------------------------------------------------------------------------
    # Shore line detection
    # ------------------------------------------------------------------------------------------------------------------
    shr = None
    if friction or resistance != -1 or not filesrc:

        # 2020-11-05 - Trying to better detect the sea
        if file_shoreline and os.path.isfile(file_shoreline) and justext(file_shoreline).lower() in ("shp", "dbf"):

            Logger.info(
                f"Rasterizing the shoreline from...<{file_shoreline}>")
            file_shoreline_shp = file_shoreline
            file_shoreline = forceext(file_shoreline_shp, "tif")
            shr, gt, prj = RasterizeLike(
                file_shoreline_shp, filedem, file_shoreline, z_value=1, nodata=0)
            Numpy2GTiff(shr, gt, prj, file_shoreline, save_nodata_as=255)

        elif not file_shoreline:

            Logger.info(f"Creating shoreline on mask...")
            shr = np.zeros_like(mask, dtype=np.uint8)
            shoreline_from_sea_mask(mask, shr)

            file_shoreline = f"{workdir}/{juststem(filedem)}.shoreline.tif"
            # file_shoreline = tempfilename(prefix="tmp_", suffix=".shoreline.tif")
            Logger.info(f"Saving shoreline on...<{file_shoreline}>")
            Numpy2GTiff(shr, gt, prj, file_shoreline, save_nodata_as=255)

    # ------------------------------------------------------------------------------------------------------------------
    # Euclidean Distance
    # ------------------------------------------------------------------------------------------------------------------
    if friction or resistance != -1:
        Logger.info("Creating the euclidean distance from shoreline...")
        distance, _, _ = GDALEuclideanDistance(file_shoreline)
        distance[np.isnan(dem)] = np.nan
        distance[mask == 1] = np.nan  # Nodata on the sea !!!important!!!
        file_distance = f"{workdir}/{juststem(filedem)}.distance.tif"
        if debug:
            Numpy2GTiff(distance, gt, prj, file_distance, save_nodata_as=-9999)

    shr = None
    # ------------------------------------------------------------------------------------------------------------------
    # Slope calculation  # TODO
    # ------------------------------------------------------------------------------------------------------------------
    if friction:
        # slope = np.empty_like(dem)
        # d8slope(dem, slope, px, py, nodata=-9999)
        slope = np.tan(dem / distance)  # <==> cotan ( distance / dem )
        file_slope = f"{workdir}/{juststem(filedem)}.slope.tif"
        if debug:
            Numpy2GTiff(slope, gt, prj, file_slope, save_nodata_as=0)

    # ------------------------------------------------------------------------------------------------------------------
    # Alter DEM
    # ------------------------------------------------------------------------------------------------------------------
    if resistance != -1:
        Logger.info(
            "dem will be modified...:dem_modified = np.fmax(dem, distance * resistance) ")

        # distance is now converted in heights
        dem_modified = np.fmax(dem, distance * resistance)

        if debug:
            fileplane = f"{workdir}/{juststem(filedem)}.plane.tif"
            Numpy2GTiff(distance * resistance, gt, prj, fileplane, save_nodata_as=-9999)

        del distance

    else:
        dem_modified = dem

    if debug:
        filemod = f"{workdir}/{juststem(filedem)}.modified.tif"
        Numpy2GTiff(dem_modified, gt, prj, filemod, save_nodata_as=-9999)

    # ------------------------------------------------------------------------------------------------------------------
    # Rasterize z-levels
    # ------------------------------------------------------------------------------------------------------------------
    if filesrc and os.path.isfile(filesrc):
        Logger.info(f"Rasterize field <{z_fieldname}> from:<{filesrc}>")
        z, _, _ = RasterizeLike(
            filesrc, filedem, burn_fieldname=z_fieldname, z_value=z_value)
        z[z == 0] = np.nan
    elif os.path.isfile(file_shoreline) and justext(file_shoreline).lower() in ("dbf", "shp") and z_value is not None:
        Logger.info(
            f"Use shoreline <{justfname(file_shoreline)}> as source @level={z_value}")
        z, _, _ = RasterizeLike(file_shoreline, filedem, z_value=z_value)
        z[z == 0] = np.nan
    elif os.path.isfile(file_shoreline) and justext(file_shoreline).lower() == "tif" and z_value is not None:
        Logger.info(
            f"Use shoreline <{justfname(file_shoreline)}> as source @level={z_value}")
        z, gt, prj = GDAL2Numpy(
            file_shoreline, dtype=np.float32, load_nodata_as=np.nan)
        z[z == 0] = np.nan  # shoreline can be 0 instead of nan
        z *= z_value
    else:
        Logger.info(f"Error!:Unable to rasterize value={z_value}")
        z = np.empty_like(dem)
        z.fill(np.nan)

    # ------------------------------------------------------------------------------------------------------------------
    #
    #       Region Growing
    #
    # ------------------------------------------------------------------------------------------------------------------
    Logger.info("Region growing...")
    # SeaGrowing(z,dem,water)            1st version
    # SeaGrowingMemOptimized(z,dem)      2nd version
    tx = datetime.datetime.now()
    if z_value is not None and z_value > 0:
        Logger.info("Using simplified fast growing algorithm...")
        sea = np.empty_like(z)
        SeaGrowingFast(z, dem_modified, sea)
    else:
        SeaGrowingFIFO(z, dem_modified)  # 3rd version
        sea = z
    del z
    Logger.info(
        f"flood done in {(datetime.datetime.now() - tx).total_seconds()}s.")

    # ------------------------------------------------------------------------------------------------------------------
    if filesea:
        Logger.info(f"Saving sea-levels on <{filesea}>...")
        Numpy2GTiff(sea, gt, prj, filesea, save_nodata_as=-9999)
    Logger.info(f"Saving watertable on <{filewd}>...")

    watertable = np.where(mask == 1, np.nan, sea - dem)
    watertable[np.isnan(dem)] = np.nan

    del sea, dem, mask
    Numpy2GTiff(watertable, gt, prj, filewd, format=of, save_nodata_as=-9999)
    del watertable

    metadata = {
        "type": "waterdepth",
        "um": "m",
        "scenario": "coastal",
        "model": f"safer_coast v{get_version()}"
    }
    SetTags(filewd, metadata)

    # overall  time
    t2 = datetime.datetime.now()
    Logger.info(f"All done in {(t2 - t0).total_seconds()}s.")
    return 0
